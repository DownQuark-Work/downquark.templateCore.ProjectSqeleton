> The business layer performs logic and passes down aggregates/etc
> The above directories contain the actual sql/aql/etc language queries.
> Which interact with the database and return the result to be passed up to the business layer

- files within the `read` and `query` directories are organized by business need
  - e.g. `auth`, `users`
- index exports based on domain
  - e.g. `Landing`, `Contact`, etc

  This allows the best of both worlds.
  - Can write the db interactions based on what we are retreiving
  - Can import them into the application based on what is required for the view

> e.g.
> Both the _auth_ and _users_ directories contain multiple queries related to their logical sections
> The _Landing_ page requires information obtained in a single `users` **read** query \[readCurrentUsers]
> And also information contained in a single `auth` **query** query \[validateCurrentUser]
> The export would look similar to
```
import * as ReadUsers from './read/users.ts' // file contains 13 total queries
import * as QueryAuth from './query/auth.ts' // file contains 8 total queries

export const db = {
  Landing: {
    getUsers: ReadUsers.readCurrentUsers,
    isValid: QueryAuth.validateCurrentUser
  }
}
```